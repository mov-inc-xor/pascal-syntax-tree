# Синтаксический анализатор
Синтаксический анализатор отрывка кода Pascal, написанный в рамках прохождения курса "Объектно-ориентированное программирование".

## Задание
При помощи собственного динамического односвязного линейного списка разработать синтаксический анализатор для следующего отрывка кода на Pascal:

``` pascal
const eps = 0.0001;
var a,b: real;
begin
  write('Введите числа a и b (a<b): ');
  readln(a,b);
  assert(a<b);
  var fa := sin(a);
  var fb := sin(b);
  assert(fb*fa<0);
  while (b-a) > eps do
  begin
    var x := (b+a)/2;
    var fx := sin(x);
    if fa*fx <= 0 then
    begin
      b := x;
    end
    else
    begin
      a := x;
      fa := fx;
    end;
  end;
writeln('Корень функции на [a,b] равен ',(b+a)/2);
end.
```

## Введение
Для обработки исключений создадим базовый класс Exception, от которого
унаследуем классы ListEmptyException (для случая, когда операция не
может выполнится ввиду пустоты списка) и SyntaxError (для уведомления
о синтаксических ошибках на этапе анализа отрывка кода программы из
задания No2). Для реализации односвязного линейного списка (ОЛС) из
задания No1 создадим шаблоны Node (узел, хранящий какие-либо данные
и ссылку на следующий узел) и List, реализующий операции над узлами
(добавление нового, исключение и др.). Для анализа программы из задания
No2 служит класс Parser, реализующий методами все правила из
грамматики выше. Для представления дерева при помощи ОЛС добавим
еще класс ParserNode, хранящий либо строку (лист дерева), либо другой
список. Отрывок исходного кода из задания No2 будем считывать из файла
при помощи std::ifstream, а в парсер передавать объект класса std::istream
для посимвольного чтения.

## Составленная грамматика
```
id - идентификатор
num - число

<prog> ::= {CONST <consts_list> } {VAR <dec_list> } BEGIN <stmt_list> END.
<consts_list> ::= <const> { , <consts_list> }
<assign> ::= {VAR} id := <exp>
<exp> ::= <term> | <term> + <exp> | <term> - <exp>
<term> ::= <factor> | <factor> * <term> | <factor> / <term>
<factor> ::= id | num | (<exp>) | <func>
<bool_sign> ::= < | > | == | != | <= | >=
<fact_arg> ::= str | <exp>
<fact_args> ::= <fact_arg> {, <fact_arg> }
<bool_exp> ::= <fact_arg> <bool_sign> <fact_arg>
<func> ::= id(<fact_args>) | id(<bool_exp>)
<const> ::= id = num
<id_list> ::= id { , <id> }
<type> ::= REAL
<dec> ::= <id_list> : <type>
<dec_list> ::= <dec> { , <dec> }
<stmt> ::= <if> | <while> | <assign> | <func>
<stmt_list> ::= <stmt> { ; <stmt> }
<if> ::= IF <bool_exp> THEN <body> ELSE <body>
<while> ::= WHILE <bool_exp> DO <body>
<body> ::= <stmt> | BEGIN <stmt_list> END
```
## Диаграмма классов
![Диаграмма классов](https://i.imgur.com/M2Bd175.png)

## Результат

```
/->"end."->[/->[/->[/->"("->[/->[/->[/->[/->"2"]->"/"->[/->"("->[/->[/->"a"]->"+"->[/->"b"]]-
>")"]]]->[/->"Корень функции на [a,b] равен "]]->")"->"writeln"]]->[/->[/->[/->"end"->[/->[/-
>[/->[/->"end"->[/->[/->[/->[/->"fx"]->":="->"fa"]]->[/->[/->[/->"x"]->":="->"a"]]]-
>"begin"]->"else"->[/->"end"->[/->[/->[/->[/->"x"]->":="->"b"]]]->"begin"]->"then"->[/->[/-
>[/->"0"]]->"=="->[/->[/->[/->"fx"]->"*"->[/->"fa"]]]]->"if"]]->[/->[/->[/->[/->"("->[/->[/-
>[/->"x"]]]->")"->""]->"sin"]->":="->"fx"->"var"]]->[/->[/->[/->[/->"2"]->"/"->[/->"("->[/-
>[/->"a"]->"+"->[/->"b"]]->")"]]->":="->"x"->"var"]]]->"begin"]->"do"->[/->[/->[/->"eps"]]-
>"e"->[/->[/->"("->[/->[/->"a"]->"-"->[/->"b"]]->")"]]]->"while"]]->[/->[/->"("->[/->[/->[/-
>"0"]]->"0"->[/->[/->[/->"fa"]->"*"->[/->"fb"]]]]->")"->"assert"]]->[/->[/->[/->[/->"("->[/-
>[/->[/->"b"]]]->")"->""]->"sin"]->":="->"fb"->"var"]]->[/->[/->[/->[/->"("->[/->[/->[/-
>"a"]]]->")"->""]->"sin"]->":="->"fa"->"var"]]->[/->[/->"("->[/->[/->[/->"b"]]->"b"->[/->[/-
>"a"]]]->")"->"assert"]]->[/->[/->"("->[/->[/->[/->"b"]]->[/->[/->"a"]]]->")"->"readln"]]-
>[/->[/->"("->[/->[/->"Введите числа a и b (a<b): "]]->")"->"write"]]]->"begin"->[/->[/-
>"real"->[/->"b"->"a"]]]->"var"->[/->[/->"0.0001"->"eps"]]->"const"
```
